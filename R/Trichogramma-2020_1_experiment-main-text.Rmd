---
title: 'Trichogramma range expansions (genetics and dynamics): 1- empirical data,  main text'
author: "Maxime Dahirel"
date: "31/03/2020"
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages, warning = FALSE, message = FALSE}
####0: PACKAGE LOADING ##to check, are all actually needed in final version?
library(MASS) #for mvrnor
library(arm)  #for inv_logit
library(matrixStats)

library(tidyverse)
library(tidyr)

library(coda)
library(rstan)
library(bayesplot)
library(brms)
rstan_options(auto_write = TRUE)
options(mc.cores = 2)
library(brms)

library(tidybayes)

library(modelr)
library(RColorBrewer)
library(cowplot)
library(ggrepel)
library(patchwork)

library(vegan)
library(RVAideMemoire)
library(matrixStats)
library(readr)
library(adegenet)
library(PopGenReport)
library(pegas)
library(poppr)
library(ggthemes)

Niter=2000
Nwarmup=1000
Nchains=4

library(here)
```

# TO DO

Nearly everything is done and clean, but still a few things to perfect:

- check priors for parameters that have been multiplied by *X* to make them fit within "general priors" (and all the others)
- find a valid colour code !!! choose colors that are colorblind AND greyscale friendly (the front/core ones are currently NOT)
- maybe more markdown comments?
- clean and tidy code, re-arrange order of lines in ggplot code
- check all loaded packages are still actually useful
- tidying up model control params (iter, chains, delta...)

## would be nice to do but probably won't for this paper 
- move model_-_front to distribution actually accounting for the discrete nature of front locations values (integer only)? Doing it with Poisson is trading an approximation for another, because Poisson is overdispersed for these data (you can change mod_front to Poisson and check this with pp_check()). A Conway Maxwell Poisson may solve this, but not 100% implemented yet in brms, and maybe overkill https://discourse.mc-stan.org/t/brms-and-conway-maxwell-poisson-distribution/7368/15

# Introduction

## Aims of project 
To understand how the position of a range expansion on a (putative) pushed/pulled gradient influences its spread dynamics and evolution

## General methods (see preprint or article for full details)

24 experimental linear landscapes were created, consisting in patches ("bottles") connected by tubes. Each patch contains ~450 host eggs as resource, replenished at each generation.

*Trichogramma brassicae* individuals were introduced in the initial patch, and the experiment ran for 14 generations, counting the starting individuals. 

At each generation, adults were left free to move and reproduce for 48 hours before being removed. These collected adults were then used as source of genetic information (this document), and as sources of further offspring for another experiment. Patches were added to the end of each landscape as needed, so there was always at least two empty patches at the front. 

We expected that (at low population sizes) reduced connectedness should lead to increased stochasticity in dispersal success and establishment difficulties:

```{r proof-of-principle, echo = FALSE}
#proof of principle that reduced connectivity restricts dispersal at low N, due to properties of the binomial distribution
expand_grid(dispersal.rate=c(0.05,0.1,0.2,0.4),N=1:450) %>% 
mutate(label = if_else(N == min(N), paste("p = ", dispersal.rate, sep=""), NA_character_)) %>%
 ggplot()+
  geom_line(aes(x=N,y=1-pbinom(0,N,dispersal.rate),col=dispersal.rate,group=dispersal.rate),size=1.2)+
  scale_y_continuous(name="Probability that at least one individual disperses")+
  scale_x_log10(name="Population size before dispersal phase")+
  scale_color_gradient(name="Mean dispersal rate",low="black",high="grey60") +
  geom_label_repel(aes(x=N,y=dispersal.rate,label=label,col=dispersal.rate),nudge_x = -2)+
  theme_half_open(11)+
  background_grid(colour.major = "grey95",colour.minor = "grey95") +
  theme(legend.position = "none")
### the effect vanishes around N=100 and become strong at N < 10 so probably too rare to be detected in previous simulation studies with K in tens of thousands
### when even with low dispersal founding units were probably rarely below the 100s
```

As a consequence, at the (relatively) low population sizes that interest us, reducing connectedness should lead expansions towards "pushed" dynamics, so two types of landscapes were set up: "reference" dispersal, with two tubes connecting successive patches, and "restricted" dispersal, with only one tube. They were hypothesized to lead to __relatively__ pulled and pushed dynamics, respectively. 12 landscapes were under putatively pushed dynamics, 12 under putatively pulled dynamics.

We have obtained two sources of information:

- __genetic information__ is obtained by genotyping adult wasps every ~4 generations (release generation, G4,8,12) at 19 microsatellite loci.
- __population dynamics information__ (population size and spread of the expansion) is obtained by photographing egg plates every generation right when they become brown-black if parasitized. Photographs are then analysed using ImageJ and Codicount to obtain estimated % of parasitism. Each image is analysed by 4 macros trained on different data ; patches are scanned by humans prior to photographs, patches with no black eggs are directly counted as zeros and thus not present in the dataset. In the main text of the manuscript (and the present document), we only use this file to get information on front location, and indirect information about dispersal by looking at where eggs are laid by the Generation 0 wasps.

# Analysis

## Loading datasets

```{r load-dataset, eval=FALSE}

###import raw datasets
raw_dynamics<- read_csv(here("data/Trichogramma_dynamics.csv"))

raw_genetics <- read_csv(here("data/Trichogramma_genetics.csv"), 
                         col_types = cols(.default=col_character())
)
##forcing locus columns to be character otherwise some important leading zeroes are lost ( a 082082 individual _homozygote with two "082" alleles_ becomes 82082, 000000 becomes 0)
## there are other way to do it by doing it downscript (see e.g. stringr::str_pad()) but best to do it right at the outset
```


The `raw_dynamics` dataset contains the following variables:

- `Generation` : number of generations since release into experimental landscapes (initially released individuals = 0)

- `Bloc` : experimental setup block, not used

- `Macro` : 4 macros used in CODICOUNT to estimate parasitism rates (see manuscript). Macro name indicates the generation on which the amcro was initially trained

- `Image` : file name, structured as `[genetic mix ID][Treatment ID][Replicate sub-ID]_[Patch ID]`. Replicate sub-ID are non-unique (they are repeated across Mix and Treatments), patch ID correspond to distance from the release patch (0 = release patch).

- `Total_surface`, `B` `H` and `P` : photograph surface (in pixels), as well ass number of pixels classified as Background, Healthy and Parasitised

- `P_black` : `P` /(`P` + `H`), parasitism rate

- `obs_count` : number of parasitised eggs, human-counted. Used for validating the CODICOUNT macros

The `raw_genetics` dataset has two types of variables:

- `ID` : a unique individual ID structured as `G[generation]_[genetic mix ID][Treatment ID]_[Replicate sub-ID]_[Individual sub-ID]` . Individual and replicate sub-ID are non-unique (they are repeated across Mix and Treatments)

- `P[X]` where [X] is a number (19 columns, 6-digit strings) : Individual genotype at microsatellite locus `P[X]`. Each allele is described by a 3-digit string, so each value corresponds to the 2 alleles pasted together


## Data preprocessing

### Dataset front: speed of the advancing range expansions

We first play with the dynamics dataset. From the raw dataset we want to produce a `data_front` dataset, to estimate how fast the wave fronts advance

We first need to make an intermediate dataset where we extract useful variables from the `Image` string, and recode some other variables. For instance, treatments are coded as `PL` (reference) and `PS` (restricted connectedness) in the dataset, based on the expected regimes (*more* PuLled and *more* PuShed, respectively). Recoded to be accurate regardless of actual results:

```{r data-popsize-temp, eval=FALSE}
data_popsize_temp<- raw_dynamics %>% 
  mutate(Mix= as.numeric(str_sub(Image,1,1)),
         Treatment = str_sub(Image,2,3),
         Replicate = as.numeric(str_sub(Image,4,4)),
         Patch = as.numeric(str_sub(Image,6,7))
  ) %>% 
  #no further processing needed; we exploit the fact that chars 6&7 are either digit dot (patchs 0 to 9)
#or digit-digit (patches 10 and beyond)
## as.numeric() resolves both correctly (e.g; "2." and "12" become 2 and 12)
  mutate(landscapeID=paste("Mix",Mix,"_Treatment",Treatment,"_Replicate",Replicate,sep="")) %>% #a unique replicate ID
  mutate(Peggs_est=P/(P+H), ## proportion of pixels counted as parasitised (estimated)
         spacetimeID=paste(landscapeID,"_Generation",Generation,"_Patch",Patch,sep=""), # a unique ID for each replicate x patch x generation combination
         Mix = factor(Mix)) %>% 
  mutate(Treatment = fct_recode(Treatment,`control`="PL",`restricted connectedness`="PS"))
```
  

Here we use the fact that only patches with parasitoids are in the dataset to get the front location in each landscape at each time: it is simply the location of the farthest colonised patch (+ some minor tidying up, again):

```{r data-front, eval = FALSE}
data_front <- data_popsize_temp %>% 
  group_by(landscapeID,Mix,Treatment,Generation) %>%
  summarise(front = max(Patch)) %>% 
  ungroup() %>% 
  group_by(landscapeID) %>% 
  arrange(Generation) %>% 
  complete(nesting(Mix,Treatment,landscapeID),
                       Generation=0:13,fill=list(front=0)) %>% ##just so we have a G0 x0 point (i.e. release) for the plots
  ungroup()

```


### Dataset genetics: dynamics of neutral genetic diversity during expansion

Then we turn to the genetics data. We're only going to generate one analysis dataset here, by converting individual microsatellite info into population/patch-level multilocus expected heterozygosity data, as our measure of genetic diversity.

As with the previous dataset, we first need to make an intermediate dataset where we extract useful variables from the `Image` string, and recode some other variables:

```{r data-genetics-1, eval=FALSE}

### STEP 1 extract relevant variables from the ID string

data_genetics<-raw_genetics %>% 
  mutate( ### info on variables is contained in each sample ID
    Generation=str_extract(ID,"G0|G4|G8|G12"),
    Mix=str_extract(ID,"_1P|_2P|_3P"),
    Treatment=str_extract(ID,"PL|PS"),
    Replicate=str_extract(ID,"L_[:digit:]|S_[:digit:]"),
    Location=str_extract(ID,"C|F")
  ) %>% 
  mutate(
    Generation=as.numeric(str_extract(Generation,"0|4|8|12")),
    Mix=as.numeric(str_extract(Mix,"1|2|3")),
    Replicate=as.numeric(str_extract(Replicate,"[:digit:]")),
    Location=fct_recode(Location,core="C",front="F")
  ) %>% 
  mutate(Location=as.character(Location)) %>% 
  mutate(Location=replace_na(Location,"origin")) %>% ## samples that are neither core nor front are from the origin
  mutate(Location=factor(Location),landscapeID=paste("Mix",Mix,"_Treatment",Treatment,"_Replicate",Replicate,sep="")) %>% 
  mutate(spacetimeID=paste(landscapeID,"_Generation",Generation,"_Location",Location,sep=""))
```

Then we convert allele columns in a format that allows us to calculate expected heterozygosity (STEP 2 below) and do that (+ some tidying, STEP 3 below):

```{r data-genetics-2, eval=FALSE}
### STEP 2 isolate the genetics markers
genmat<- df2genind(select(data_genetics,starts_with("P")),####all allelic columns start with a "P"
            ncode=3,
            NA.char = "000",
            ind.names=data_genetics$ID,pop=data_genetics$spacetimeID) #ncode=3 bc 3 characters for one allele

### STEP 3 generate summary of all other columns ; one row = one sampled patch
data_genetics <- data_genetics %>%   
  group_by(spacetimeID) %>% 
  mutate(Nsampled = length(Location))%>%
  ungroup() %>% 
  select(-starts_with("P"), -ID) %>% 
  distinct() %>% 
  inner_join(
    tibble(Hexp=Hs(genmat),spacetimeID=names(Hs(genmat)))
    ) %>% 
  mutate(is.front=-0.5*(Location=="core")+0.5*(Location=="front"), ## dummy variable to make interpreting interaction coefs easier
         Treatment=fct_recode(Treatment,`control`="PL",`restricted connectedness`="PS"))

```

Our metric of genetic diversity (expected heterozygosity) is stored in `Hexp`.

## Data analysis

Now we have everything we need, we can fit some models! (see manuscript for details)


### Dataset front: speed of the advancing range expansions

We here assume each front initially advances at a speed that may not be the asymptotic/equilibrium speed (which is what interests us), due to various stochastic reasons, but end up converging to it more or less exponentially:

```{r model-front, eval = FALSE}

if(file.exists(here("R_output","model1_front_expe.Rdata")))
  {
  load(here("R_output","model1_front_expe.Rdata"))
  }else
    {
  bf_front <- bf(front~log(speed*Generation), 
               nlf(speed~speedasym+(speedstart-speedasym)*exp(-(Generation-1)*rate)),
               ##Generation - 1 because moving the startspeed away from t0 (where it doesn't actually exist) to t1 stabilises everything
               nlf(rate~10^(lograte)),
               nlf(speedasym~exp(logspeedasym)),
               nlf(speedstart~exp(logspeedstart)),
           logspeedasym~0+Treatment+(1|1|landscapeID),
           logspeedstart~0+Treatment+(1|1|landscapeID),
           lograte~0+Treatment+(1|1|landscapeID),
           family=lognormal,nl=TRUE)

prior_front <- c(
          set_prior("normal(0,1)",nlpar=c("logspeedasym","logspeedstart"),class="b"),
          set_prior("normal(0,1)",nlpar=c("lograte"),class="b"),
          set_prior("normal(0,1)",nlpar=c("logspeedasym","lograte","logspeedstart"),class="sd"),
          set_prior("normal(0,1)",class="sigma"),
          set_prior("lkj(2)",class="cor")
        )

mod_front=brm(bf_front, 
        data=subset(data_front,Generation>0),chains=Nchains,iter=Niter,warmup=Nwarmup,
        prior= prior_front,control=list(adapt_delta=0.95,max_treedepth=10),
        seed = 42)

save(list="mod_front", file=here("R_output","model1_front_expe.Rdata"))
}

```


```{r summary-model-front, eval = FALSE}

summary(mod_front)

summary_front <- mod_front %>%
  posterior_samples() %>%
  select(starts_with(c("Intercept", "b_", "sd_", "cor_", "sigma"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi() %>% 
  print(n=Inf)

mcmc_rank_overlay(mod_front, pars = summary_front$name)

###prediction intervals around each point
ppc_ribbon(yrep=predict(mod_front,summary=FALSE),
           x=rank(predict(mod_front)[,1]),
           y=subset(data_front$front,data_front$Generation>0),
           prob = 0.5, prob_outer=0.95)

## TO DO for correlations and for sigma
```

### Dataset genetics: dynamics of neutral genetic diversity during expansion

Our model here is rooted in theory (see manuscript for references) and assumes genetic diversity declines exponentially through time. The decay rate parameter is our parameter of interest here:

```{r model-genetics, eval = FALSE}
if(file.exists(here("R_output","model2_genet_expe.Rdata")))
  {
  load(here("R_output","model2_genet_expe.Rdata"))
  }else
    {

prior_genetics=c(
  set_prior("normal(0,1.5)",nlpar=c("logitH0"),class="b"),
  set_prior("normal(0,1)",nlpar=c("logdecay"),class="b"),
  set_prior("normal(0,1)",nlpar=c("logdecay","logitH0"),class="sd"),
  set_prior("lkj(2)",class="cor")
)

bf_genetics=bf(logit(Hexp)~logit(H0*exp(-decay*Generation)),
               nlf(H0~inv_logit(logitH0)),
               nlf(decay~10^(logdecay)),
               logitH0~1+(1|1|landscapeID),
               logdecay~0+Treatment+Treatment:is.front+(is.front|1|landscapeID),
               family=student(),nl=TRUE)

mod_genetics=brm(bf_genetics,
                 data=data_genetics,
                 chains=Nchains,iter=Niter*2,warmup=Nwarmup*2,
                 prior=c(prior_genetics,
                         set_prior("normal(0,1)",class="sigma"),
                         set_prior("gamma(2,0.1)",class="nu")),
                 seed=42,control=list(adapt_delta=0.8,max_treedepth=10)
)

#the gamma(2, 0.1) prior for nu follows again recommendations from the Stan wiki
#https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations

save(list="mod_genetics",file=here("R_output","model2_genet_expe.Rdata"))
}
```

```{r summary-model-genetics, eval = FALSE}
summary(mod_genetics)

summary_genetics <- mod_genetics %>%
  posterior_samples() %>%
  select(starts_with(c("Intercept", "b_", "sd_", "cor_", "sigma","nu"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi() %>% 
  print(n=Inf)

mcmc_rank_overlay(mod_genetics, pars = summary_genetics$name)

###prediction intervals around each point
ppc_ribbon(yrep=invlogit(predict(mod_genetics,summary=FALSE)),
           x=rank(predict(mod_genetics)[,1]),
           y=data_genetics$Hexp,
           prob = 0.5, prob_outer=0.95)
```

#### Aside:  why use a logit-Student model, and not simply a Beta model (or a logit-normal)?  

Well, we did both, and the former outperforms the others, maybe because it accounts better for rare outliers (like sudden **increases** in diversity with time) that are visible on plots (which would be expected due to sampling when selecting individuals before genotyping, or due to the expansion process itself):

```{r model-genetics-beta, eval = FALSE}
if(file.exists(here("R_output","model2bis_genet_expe.Rdata")))
  {
  load(here("R_output","model2bis_genet_expe.Rdata"))
  }else
    {
bf_genetics2=bf(Hexp~logit(H0*exp(-decay*Generation)),
               nlf(H0~inv_logit(logitH0)),
               nlf(decay~10^(logdecay)),
               logitH0~1+(1|1|landscapeID),
               logdecay~0+Treatment+Treatment:is.front+(is.front|1|landscapeID),
               nlf(phi~1/invphi),
               invphi~1,
               family=Beta(link_phi="identity"),nl=TRUE)

mod_genetics2=brm(bf_genetics2,
                 data=data_genetics,
                 chains=Nchains,iter=Niter*2,warmup=Nwarmup*2,
                 prior=c(prior_genetics,
                         set_prior("normal(0,1)",nlpar="invphi",lb=0)),
                 seed=42,control=list(adapt_delta=0.8,max_treedepth=10)
)

save(list="mod_genetics2",file=here("R_output","model2bis_genet_expe.Rdata"))
}
##can't compare both models directly with LOO since the responses are not the same, logit(Hexp) versus Hexp
## but let's check their performance:

pp_check(mod_genetics,type="loo_pit_overlay",nsamples=2000)

pp_check(mod_genetics2,type="loo_pit_overlay",nsamples=2000)

##some evidence that the Beta model is slightly more miscalibrated compare to the Student on logits
## can also be seen using loo_pit_qq
#####

```

While we can't directly compare the Student on logits and the Beta models with LOO, we can compare the student with a Gaussian model on logits, which should be close to a Beta in terms of behaviour:


```{r model-genetics-logit-normal, eval = FALSE}
if(file.exists(here("R_output","model2ter_genet_expe.Rdata")))
  {
  load(here("R_output","model2ter_genet_expe.Rdata"))
  }else
    {
bf_genetics3=bf(logit(Hexp)~logit(H0*exp(-decay*Generation)),
               nlf(H0~inv_logit(logitH0)),
               nlf(decay~10^(logdecay)),
               logitH0~1+(1|1|landscapeID),
               logdecay~0+Treatment+Treatment:is.front+(is.front|1|landscapeID),
               family=gaussian,nl=TRUE)

mod_genetics3=brm(bf_genetics3,
                 data=data_genetics,
                 chains=Nchains,iter=Niter*2,warmup=Nwarmup*2,
                 prior=c(prior_genetics,
                         set_prior("normal(0,1)",class="sigma")),
                 seed=42,control=list(adapt_delta=0.8,max_treedepth=10)
)

save(list="mod_genetics3",file=here("R_output","model2ter_genet_expe.Rdata"))
     
}

##looking at 
## summary(mod_genetics)
## summary(mod_genetics2)
## summary(mod_genetics3)
## confirms that the logit-normal behaves more or less like the Beta

pp_check(mod_genetics,type="loo_pit_overlay",nsamples=2000)

pp_check(mod_genetics2,type="loo_pit_overlay",nsamples=2000)

pp_check(mod_genetics3,type="loo_pit_overlay",nsamples=2000)

## the LOO PIT graphs too
##, so now let's compare logit student and logit normal:


if(file.exists(here("R_output","loo_genet_expe.Rdata")))
  {
  load(here("R_output","loo_genet_expe.Rdata"))
  }else
    {
loo1<-loo(mod_genetics,reloo=TRUE)

loo3<-loo(mod_genetics3, reloo=TRUE)  ##reloo = TRUE needed because some "problematic" obs with high pareto_k

save(list=c("loo1","loo3"),file=here("R_output","loo_genet_expe.Rdata"))
}

loo_compare(loo1,loo3)

data_genetics$elpd1 <- loo1$pointwise[,"elpd_loo"]
data_genetics$elpd3 <- loo3$pointwise[,"elpd_loo"]

table(data_genetics$elpd1-data_genetics$elpd3 > 0)

##evidence that logit-student is better
#####
```

## Postprocessing : plots and summaries

Now we can draw the figures associated with these models, and maybe get back some useful comparisons at the same time?

```{r color-palettes, eval=FALSE}

TRTpalette <- c("#F0E442","#009E73", "#F0E442","#CC79A7") # a 4 color palette so it can also be used for simulation results
frontcorePalette <- c("#000000", "#E69F00", "#56B4E9") # 3 colors, for origin (black), front and core patches

```

### Dataset front: speed of the advancing range expansions

```{r figure-front, eval = FALSE}

## PART 1 : advance of the fronts through time, predicted and observed
p1 <- data_front %>% 
  ungroup() %>% 
  mutate(landscapeID= landscapeID[1]) %>% 
  select(Treatment,landscapeID) %>% 
  distinct() %>% 
  expand_grid(Generation=(1:130)/10) %>% 
  add_fitted_draws(mod_front,re_formula=NA) %>% 
  mutate(.value_front=.value) %>% 
  ungroup() %>% 
  mutate(Treatment=fct_recode(Treatment,reference="control")) %>% 
  group_by(Generation,Treatment) %>% 
  ggplot()+
  stat_lineribbon(aes(x=Generation,y=.value_front,fill=Treatment),.width=0.95,alpha=0.3,point_interval = mean_hdi)+
  geom_line(data=data_front %>% mutate(Treatment=fct_recode(Treatment,reference="control")),aes(x=Generation,y=front,group=landscapeID,col=Treatment))+
  scale_fill_manual(values=TRTpalette[c(1,4)])+
  scale_colour_manual(values=TRTpalette[c(1,4)])+
  scale_y_continuous("Front location (patches from release)")+
  facet_wrap(~Treatment) +
  theme_half_open(11) +
  background_grid(colour.major = "grey95",colour.minor = "grey95")
  
  
## PART 2: posterior of the key parameter: asymptotic speed 
p2 <- data_front %>% 
  ungroup() %>% 
  mutate(landscapeID= landscapeID[1],Generation=1) %>% 
  select(Treatment,landscapeID,Generation) %>% 
  distinct() %>%
  add_fitted_draws(mod_front,nlpar="logspeedasym",re_formula=NA) %>% 
  mutate(.value=exp(.value)) %>% ##backtransformation
  ungroup() %>% 
  mutate(Treatment=fct_recode(Treatment,reference="control")) %>% 
  ggplot()+
  geom_eye(aes(x=Treatment,y=.value,fill=Treatment),slab_alpha=0.3,point_interval = mean_hdi)+
  scale_fill_manual(values=TRTpalette[c(1,4)])+
  scale_x_discrete("Landscape type")+
  scale_y_continuous("Asymptotic velocity (patches per generation, posterior)") +
  theme_half_open(11) +
  background_grid(colour.major = "grey95",colour.minor = "grey95")



p1 / p2 + plot_annotation(tag_levels="A") + plot_layout(guides="collect") &
  theme(legend.position="none")


data_front %>% 
  ungroup() %>% 
  mutate(landscapeID= landscapeID[1],Generation=1) %>% 
  select(Treatment,landscapeID,Generation) %>% 
  distinct() %>%
  add_fitted_draws(mod_front,nlpar="logspeedasym",re_formula=NA) %>% 
  mutate(.value=exp(.value)) %>% ##backtransformation
  compare_levels(variable=.value,by=Treatment) %>% 
  mean_hdi()
```


### Dataset genetics: dynamics of neutral genetic diversity during expansion

```{r figure-genetics, eval = FALSE}


p1 <- data_genetics %>% 
  mutate(landscapeID = landscapeID[1]) %>% 
  select(Treatment,is.front,Location,landscapeID) %>% 
  distinct() %>% 
  filter(is.front!=0) %>% 
  expand_grid(Generation=c(0:120)/10) %>%  
  add_fitted_draws(mod_genetics,re_formula=NA) %>% 
  mutate(.value=invlogit(.value)) %>% 
  ungroup() %>% 
  mutate(Treatment=fct_recode(Treatment,reference="control")) %>% 
  ggplot()+
  stat_lineribbon(aes(x=Generation,y=.value,fill=Location),.width=c(0.66,0.95),alpha=0.3,point_interval = mean_hdi)+
  geom_point(data=data_genetics %>%   mutate(Treatment=fct_recode(Treatment,reference="control")) ,aes(x=Generation+is.front,y=Hexp,bg=Location),pch=21,size=2)+
  #alternate geom_point, to display the difference in elpd between logit student and logit normal through point size:
  #geom_point(data=data_genetics,aes(x=Generation+is.front,y=Hexp,bg=Location,size=elpd1-elpd3),pch=21)+
  scale_fill_manual(values=frontcorePalette[c(3,2,1)])+
  scale_y_continuous(name = "Genetic diversity (Hexp)") +
  scale_x_continuous(name = "Generations since start") +
  facet_wrap(~Treatment) + 
  theme_half_open(11) +
  background_grid(colour.major = "grey95",colour.minor = "grey95")

p2<- data_genetics %>%  
  mutate(landscapeID = landscapeID[1], Generation = 1) %>% 
  select(landscapeID,is.front,Location,Treatment,Generation) %>% 
  distinct() %>% 
  add_fitted_draws(mod_genetics,nlpar="logdecay",re_formula=NA) %>% 
  mutate(.value=10^(.value)) %>% 
  filter(is.front!=0) %>%
  ungroup() %>% 
  mutate(Treatment=fct_recode(Treatment,reference="control")) %>% 
  ggplot()+
  geom_eye(aes(x=Location,y=.value,fill=Location),slab_alpha=0.3)+
  scale_fill_manual(values=frontcorePalette[c(3,2,1)])+
  facet_wrap(~Treatment)+
  scale_y_continuous(expression(paste("genetic diversity decay rate  ",lambda))) +
  theme_half_open(11) +
  background_grid(colour.major = "grey95",colour.minor = "grey95") +
  theme(legend.position = "none")

p1/p2 +plot_annotation(tag_levels = "A") + plot_layout(guides="collect")
```

```{r summary-stats-genetics, eval = FALSE}

newdata <- data_genetics %>%  
  mutate(landscapeID = landscapeID[1], Generation = 1) %>% 
  select(landscapeID,is.front,Location,Treatment,Generation) %>% 
  filter(is.front!=0) %>% 
  distinct() %>% 
  add_fitted_draws(mod_genetics,nlpar="logdecay",re_formula=NA) %>% 
  mutate(.value=10^(.value)) 

## differences in decay between treatments per location
newdata %>% 
  group_by(Location) %>% 
  compare_levels(.value,by=Treatment,fun=`-`) %>%
  mean_hdi()

## differences in decay between location per treatment
newdata %>% 
  group_by(Treatment) %>% 
  compare_levels(.value,by=Location,fun=`-`) %>%
  mean_hdi()

## and is the latter difference different among treatments?

newdata %>% 
  group_by(Treatment) %>% 
  compare_levels(.value,by=Location,fun=`-`) %>% 
  ungroup() %>% 
  compare_levels(.value,by=Treatment,fun=`-`) %>% 
  mean_hdi()
```

